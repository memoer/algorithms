package programmers.Lv2;

public class P92342 {
  public static void main(String[] args) {
    int n = 5;
    int[] info = {2, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0};
    for (int i : new Solution().solution(n, info)) System.out.print(i + ", ");
    System.out.println();
  }

  private static class Solution {
    /*
    1. 어피치가 화살 n발을 다 쏜 후에, 라이언이 n발을 쏜다.
    2. 점수 계산
      1. 과녁 점수는 가장 작은 원이 10점, 가장 큰 원의 바깥쪽이 0점
      2. 만약 k[1~10]점을 어피치가 a발을 맞췄고 라이언이 b발을 맞췄을 경우, 더 많은 화살을 k점에 맞힌 선수가 k점을 가져간다.
        * Ex) 5점을 각각 "2번, 3번" 맞춘다면, 3번 맞춘 애가 5점을 가져간다.
        * Ex) 5점을 3발 맞춰도, 5점만 가져간다.
        * 단, "a=b" 일 경우는 어피치가 k점을 가져갑니다.
        * "a=b=0"인 경우, 라이언과 어피치 모두 k점을 가져가지 않습니다.
      3. 모든 과녁 점수에 대하여 각 선수의 최종 점수를 계산합니다.
    3. 최종 점수가 더 높은 선수를 우승자로 결정한다.
      * 단, 최종 점수가 같을 경우 어피치를 우승자로 결정한다.
     */
    /*
    1. 현재 상황 -> 어피치가 화살 n발을 다 쏜 후이고, 라이언이 쏠 차례
    2. 라이언은 어피치를 가장 큰 점수 차이로 이기기 위해 n 발의 화살을 어떤 과녁 점수에 맞혀야 하는지를 구하려고 한다.
     */
    /*
    n -> 화살의 개수
    info -> 어피치가 맞힌 과녁 점수의 개수를 10점부터 0점까지 순서대로 담은 정수 배열
    return -> 라이언이 가장 큰 점수 차이로 우승하기 위해 n발의 화살을 어떤 과녁 점수에 맞혀야 하는지를 10점부터 0점까지 순서대로 정수 배열에 담은 값A
      - 라이언이 우승할 수 없는 경우 즉, 무조건 지거나 비기는 경우는 [-1] 을 return
     */
    public int[] solution(int n, int[] info) {
      return new int[]{};
    }
  }
}
